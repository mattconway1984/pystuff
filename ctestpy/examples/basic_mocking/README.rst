Basic Mocking Example
=====================

This provides a basic example of testing a C library using ctestpy, where
the C library under test needs to interface with a local mock.

Basic APIs
----------

The code under test implements the APIs as declared in in ``src/controller.h``.
It is the implementation of these APIs that shall be compiled and called from
the unit tests.

Power On 
""""""""

The controller supports an API to power on the device, for example, as shown in
the following sequence diagram:

.. uml::

    client -> controller: power_on()
    activate controller 
    
    controller -> gpio_driver: get_pio(POWER_GPIO)
    activate gpio_driver
    
    gpio_driver -> controller: LOW
    deactivate gpio_driver
    
    controller -> gpio_driver: set_pio(POWER_GPIO, HIGH)
    activate gpio_driver
    
    gpio_driver -> controller: success
    deactivate gpio_driver
    
    controller -> client : success
    deactivate controller 

Note: This diagram includes a conditional within the controller; it must first 
check if the power pin is currently low, if it is, it shall drive it high in 
order to power on the underlying hardware.

Power Off 
"""""""""

The controller supports an API to power off the device, for example, as shown in
the following sequence diagram:

.. uml::

    client -> controller: power_off()
    activate controller 
    
    controller -> gpio_driver: get_pio(POWER_GPIO)
    activate gpio_driver
    
    gpio_driver -> controller: HIGH 
    deactivate gpio_driver
    
    controller -> gpio_driver: set_pio(POWER_GPIO, LOW)
    activate gpio_driver
    
    gpio_driver -> controller: success
    deactivate gpio_driver
    
    controller -> client : success
    deactivate controller 

Note: This diagram includes a conditional within the controller; it must first 
check if the power pin is currently high, if it is, it shall drive it low in 
order to power off the underlying hardware.

Unit Testing
------------

To unit test the APIs of the controller "library" Python shall be used in order
to utilise the comprehensive Python test framework, pytest. On top of that,
CTestPy will be used to create necessary bindings for test code to drive the
code under test. Unit tests are easy to maintain in Python, and can be
implemented very effectively. 

tests/test_controller.py
""""""""""""""""""""""""

This script contains unit tests for the code under test, the key bit to
understand is this method:

.. code-block:: python3

    @contextmanager
    def builder():
        with Builder(
                testing=CodeUnderTest(
                    source=pathlib.Path('src/controller.c'),
                    header=pathlib.Path('src/controller.h')),
                mocking=[
                    Mock(header=pathlib.Path('src/gpio_driver.h')),
                    Mock(header=pathlib.Path('src/gpio_driver_new.h'))
                ]) as builder:
            yield builder

which is designed to create the CTestPy ``Builder`` object, this object will:

#. Automatically generate Python bindings in order to allow the code under test
   to be controlled by the unit tests.
#. Automatically generate mock implementations for each method defined in the
   list of C headers passed as the ``mocking`` argument when the ``Builder`` class
   is created.
#. Ensure any generated code files are cleanly tidied up after a test run.

The test code can rely on CTestPy to generate the Python bindings, in order to
control the code under test, the unit tests can call methods, for example:

.. code-block:: python3

    def test_something_useful():
        with builder() as build:
            # Calls the ``power_on`` method in the C code under test:
            build.testing.power_on()
            # Calls the ``power_off`` method in the C code under test:
            build.testing.power_off()

However, these methods depend on external methods which shall be mocked. In
order for tests to control the mocks, they can do so via methods:

.. code-block:: python3

    def test_something_useful():
        with builder() as build:
            expected_gpio = 0x1a  # power gpio
            retval = 0xff  # pretend the power gpio is set high (the return value)
            # Setup an expectation that ``get_gpio`` will be called by the code under 
            # test:
            build.mocking.get_gpio_expect_and_return(expected_gpio, retval=retval)
            # Now call the code under test, the mocks generated by CTestPy shall 
            # automatically verify against expectations.
            build.testing.power_on()

Each mocked method shall be given a ``<method_name>_expect_and_return`` method
which is how the unit test is expected to control the mock by setting 
expectations. Arguments to these methods are supplied in order as they appear
within the C Header, method declaration. there is an optional keyword argument
which the unit test is expected to pass for any mocked method that returns a
value, and that is ``retval=<value>``. Passing this simply informs the mock of
the value it must return when it is invoked by the code under test.

The unit test code is allowed to setup multiple expectations, but they must be
created in the correct order they are expected to be called (note: this may
change in future versions of CTestPy). For example:

.. code-block:: python3

    def test_something_useful():
        with builder() as build:
            # setup expectations:
            build.mocking.some_method_expect_and_return(1, retval=5)
            build.mocking.some_method_expect_and_return(2, retval=6)
            build.mocking.some_method_expect_and_return(3, retval=7)
    
            # invoke code under test, which should call ``some_method`` precisely 3x,
            # as per the expectations above:
            build.testing.method_under_test()
